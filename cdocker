#!/usr/bin/env node

var fs = require('fs');
var os = require('os');
var path = require('path');
var Docker = require('dockerode');
var pretty = require('prettysize');
var rangeParser = require('parse-numeric-range');
var deferred = require('deferred');
var Table = require('cli-table2');
var minimatch = require('minimatch');
var expand = require('brace-expansion');
var randomItem = require('random-item');

var config = {
    containers: {},
    nodes: {}
};
var configfile = path.join(os.homedir(), '.cdocker.json');

var loadConfig = function () {
    try {
        var data = fs.readFileSync(configfile);
        config = JSON.parse(data);
    }
    catch (err) {
        console.log('Warning, could not load config', err.message);
    }
};

var saveConfig = function () {
    fs.writeFile(configfile, JSON.stringify(config, 3), function (err) {
        if (err) {
            console.log('Error saving configuration', err);
            return;
        }
    });
};

loadConfig();

var getNodeInfo = function (node) {
    var promise = deferred();
    new Docker({host: config.nodes[node].ip, port: config.nodes[node].port}).info(function (err, data) {
        if (err) {
            promise.resolve({
                ip: config.nodes[node].ip,
                status: 'down',
                reason: err
            });
        } else {
            data.ip = config.nodes[node].ip;
            data.status = 'up';
            promise.resolve(data);
        }
    });
    return promise.promise;
}

var getBestOrderNodes = function () {
    var promise = deferred();
    // This function will be called when 'any' node is requested
    // It simply sorts the nodes by number of running containers and takes the lowest
    // Where many nodes are joint-lowest, we pick a random one
    deferred.map(Object.keys(config.nodes), getNodeInfo)(function (result) {
        var running = {};
        for (var i = result.length; i--; ) {
            var key = result[i].ContainersRunning;
            if(!(key in running)) {
                running[key] = [];
            }
            running[key].push(result[i].Name);
        }
        // do the sort and produce 1 array
        var sortedkeys = Object.keys(running).sort(function (a,b) {return a-b}).reverse();
        var sortednodes = [];
        for (var i = sortedkeys.length; i--; ) {
            for (var j = running[sortedkeys[i]].length; j--; ) {
                sortednodes.push(running[sortedkeys[i]][j]);
            }
        }
        promise.resolve(sortednodes);
    });
    return promise.promise;
}

var argv = require('yargs')
    .usage("Run Docker commands on a cluster without Swarm.")
    .command('node', 'Node related commands', function (yargs) {
        return yargs
            .command('add [ip]', 'Add one or more nodes to the cluster', function (yargs) {
                yargs.option('port', {
                        describe: 'Port for the Docker Engine API',
                        default: 2375
                    })
                ;
            }, function (argv) {
                // the ip specified may specify a range of ips to add (using brace syntax)
                // and do these in parallel the right way
                deferred.map(expand(argv.ip), function (ip) {
                    var promise = deferred();
                    var newnode = new Docker({host: ip, port: argv.port});
                    newnode.info(function(err, data) {
                        if(err) {
                            console.log("Could not add", ip, ":", err.message);
                            promise.resolve();
                        } else {
                            console.log("Added engine at", ip);
                            config.nodes[data.Name] = {
                                port: argv.port,
                                ip: argv.ip
                            };
                            promise.resolve();
                        }
                    });
                    return promise.promise;
                })(function () {
                    console.log('All done.');
                    saveConfig();
                });
            })
            .command('remove [ip]', 'Remove a node from the cluster')
            .command('ls', 'List nodes', function () {}, function (argv) {
                deferred.map(Object.keys(config.nodes), getNodeInfo)(function (result) {
                    // build a fancy table
                    var table = new Table({
                        head: ['IP', '', 'Node', 'OS/Arch', 'CPUs', 'RAM', 'Running', 'Stopped'],
                        style: {
                            head: []
                        }
                    });
                    for (var i = 0; i < result.length; i++) {
                        if (result[i].status == 'up') {
                            table.push([
                                result[i].ip,
                                result[i].status,
                                result[i].Name,
                                result[i].OSType+'/'+result[i].Architecture,
                                result[i].NCPU,
                                pretty(result[i].MemTotal),
                                result[i].ContainersRunning,
                                result[i].ContainersStopped
                            ]);
                        } else {
                            table.push([
                                result[i].ip,
                                result[i].status
                            ]);
                        }
                    };
                    console.log(table.toString());
                });
            })
            .demandCommand(1)
        ;
    })
    .command('run', 'Run a command in a new container', function () {}, function (argv) {
        // expand container names
        if(!argv.name) {
            console.error("Please specify a container name (or array using brace expansion)");
            process.exit(1);
        }
        var names = expand(argv.name);
        var containers = [];
        for (var i = names.length; i--; ) {
            containers.push({
                name: names[i],
                node: 'any'
            });
        }
        // make sure we alway have array for env vars
        if (!(argv.e instanceof Array)) {
            argv.e = [argv.e];
        }
        // look for and expand constraints
        for (var i = argv.e.length; i--; ) {
            var keysplit = argv.e[i].split(":");
            if (keysplit[0] == 'constraint') {
                if (keysplit[1].includes("==")) {
                    var valuesplit = keysplit[1].split("==");
                    var constraint = valuesplit[0];
                    var pattern = expand(valuesplit[1]);
                    var count = 0;
                    for (var j = containers.length; j--; ) {
                        containers[j][constraint] = pattern[count];
                        if (count == pattern.length) {
                            count = 0;
                        } else {
                            count++;
                        }
                    }
                } else {
                    console.error("This constraint is not supported yet:", argv.e[i]);
                    process.exit(1);
                }
            }
        }
        // if 'any' node is specified, we must run them syncronously because there is no
        // scheduler, and we will recalculate the best node after each container is started
        // otherwise, we can launch them all in parallel
        getBestOrderNodes().then(function (nodes) {
            console.log(nodes);
        });
        /*for (var i = containers.length; i--; ) {
            var cmdline = process.argv.slice(2).join(" ");
            if (containers[i].node == 'any') {
                
            }
            cmdline = cmdline.replace(argv.name, containers[i].name);
            console.log('DOCKER_HOST='+containers[i].node, 'docker', cmdline);
        }*/
    })
    .command('start', 'Start one or more stopped containers')
    .command('stop', 'Stop one or more running containers')
    .command('kill', 'Kill one or more running containers')
    .command('rm', 'Remove one or more containers')
    .command('pull', 'Pull an image or a repository from a registry')
    .command('rmi', 'Remove one or more images')
    .command('ps', 'List containers')
    .demandCommand(1)
    .help('h')
    .alias('h', 'help')
    .argv
;