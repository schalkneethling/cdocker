#!/usr/bin/env node

var fs = require('fs');
var os = require('os');
var path = require('path');
var Docker = require('dockerode');
var pretty = require('prettysize');
var rangeParser = require('parse-numeric-range');
var deferred = require('deferred');
var Table = require('cli-table2');
var minimatch = require('minimatch');
var expand = require('brace-expansion');
var randomItem = require('random-item');
var child_process = require('child_process');

var config = {
    containers: {},
    nodes: {}
};
var configfile = path.join(os.homedir(), '.cdocker.json');

var loadConfig = function () {
    try {
        var data = fs.readFileSync(configfile);
        config = JSON.parse(data);
    }
    catch (err) {
        console.log('Warning, could not load config', err.message);
    }
};

var saveConfig = function () {
    fs.writeFile(configfile, JSON.stringify(config, null, 10), function (err) {
        if (err) {
            console.log('Error saving configuration', err);
            return;
        }
    });
};

loadConfig();

var getNodeInfo = function (node) {
    var promise = deferred();
    new Docker({host: config.nodes[node].ip, port: config.nodes[node].port}).info(function (err, data) {
        if (err) {
            promise.resolve({
                ip: config.nodes[node].ip,
                status: 'down',
                reason: err
            });
        } else {
            data.ip = config.nodes[node].ip;
            data.status = 'up';
            promise.resolve(data);
        }
    });
    return promise.promise;
}

var getMatchingNodes = function (nodenames, constraint) {
    // nodes are matched based on name and labels in the config.json
    var matchednodes = [];
    for (var i = nodenames.length - 1; i >= 0; i--) {
        // test the constraint against this node
        var matched = true;
        if (constraint.includes("==")) {
            var csplit = constraint.split("==");
            if (csplit[0] == "node") {
                // node
                if (csplit[1].includes("*")) {
                    // glob
                    if (!minimatch(nodenames[i], csplit[1])) {
                        matched = false;
                    }
                } else {
                    // expand
                    var match_names = expand(csplit[1]);
                    if (!match_names.includes(nodenames[i])) {
                        matched = false;
                    }
                }
            } else {
                // label
                if (config.nodes[nodenames[i]].labels) {
                    for (var j = config.nodes[nodenames[i]].labels.length - 1; j >= 0; j--) {
                        var lsplit = config.nodes[nodenames[i]].labels[j].split("=");
                        // if key matches
                        if (csplit[0] == lsplit[0]) {
                            // test value
                            if (csplit[1].includes("*")) {
                                // glob
                                if (!minimatch(lsplit[1], csplit[1])) {
                                    matched = false;
                                }
                            } else {
                                // expand
                                var match_values = expand(csplit[1]);
                                if (!match_values.includes(lsplit[1])) {
                                    matched = false;
                                }
                            }
                        } else {
                            matched = false;
                        }
                    };
                } else {
                    matched = false;
                }
            }
        } else {
            console.error("This constraint is not supported yet:", constraint);
            process.exit(1);
        }
        if (matched) {
            matchednodes.push(nodenames[i]);
        }
    };
    return matchednodes;
}

var argv = require('yargs')
    .usage("Run Docker commands on a cluster without Swarm.")
    .command('node', 'Node related commands', function (yargs) {
        return yargs
            .command('add [ip]', 'Add one or more nodes to the cluster', function (yargs) {
                yargs.option('port', {
                        describe: 'Port for the Docker Engine API',
                        default: 2375
                    })
                ;
            }, function (argv) {
                // the ip specified may specify a range of ips to add (using brace syntax)
                // and do these in parallel the right way
                deferred.map(expand(argv.ip), function (ip) {
                    var promise = deferred();
                    var newnode = new Docker({host: ip, port: argv.port});
                    newnode.info(function(err, data) {
                        if(err) {
                            console.log("Could not add", ip, ":", err.message);
                            promise.resolve();
                        } else {
                            console.log("Added engine at", ip);
                            config.nodes[data.Name] = {
                                port: argv.port,
                                ip: argv.ip,
                                labels: data.Labels
                            };
                            promise.resolve();
                        }
                    });
                    return promise.promise;
                })(function () {
                    console.log('All done.');
                    saveConfig();
                });
            })
            .command('remove [ip]', 'Remove a node from the cluster')
            .command('ls', 'List nodes', function () {}, function (argv) {
                deferred.map(Object.keys(config.nodes), getNodeInfo)(function (result) {
                    // build a fancy table
                    var table = new Table({
                        head: ['IP', '', 'Node', 'OS/Arch', 'CPUs', 'RAM', 'Running', 'Stopped', 'Labels'],
                        style: {
                            head: []
                        }
                    });
                    for (var i = 0; i < result.length; i++) {
                        if (result[i].status == 'up') {
                            table.push([
                                result[i].ip,
                                result[i].status,
                                result[i].Name,
                                result[i].OSType+'/'+result[i].Architecture,
                                result[i].NCPU,
                                pretty(result[i].MemTotal),
                                result[i].ContainersRunning,
                                result[i].ContainersStopped,
                                JSON.stringify(result[i].Labels)
                            ]);
                        } else {
                            table.push([
                                result[i].ip,
                                result[i].status
                            ]);
                        }
                    };
                    console.log(table.toString());
                });
            })
            .demandCommand(1)
        ;
    })
    .command('run', 'Run a command in a new container', function () {}, function (argv) {
        var overprovision = false;
        // expand container names
        if(!argv.name) {
            console.error("Please specify a container name (or array using brace expansion)");
            process.exit(1);
        }
        var names = expand(argv.name);
        var containers = [];
        var constraints = [];
        for (var i = names.length; i--; ) {
            containers.push({
                name: names[i],
                node: 'unallocated'
            });
        }
        // make sure we alway have array for env vars
        if (argv.e) {
            if (!(argv.e instanceof Array)) {
                argv.e = [argv.e];
            }
            // look for constraints
            for (var i = argv.e.length; i--; ) {
                var keysplit = argv.e[i].split(":");
                if (keysplit[0] == 'constraint') {
                    constraints.push(keysplit[1]);
                }
            }
        }
        // run each constraint sequentially to whittle down the nodes
        var nodes = Object.keys(config.nodes);
        for (var i = constraints.length - 1; i >= 0; i--) {
            nodes = getMatchingNodes(nodes, constraints[i])
        };
        // see what we got
        if (nodes.length == 0) {
            console.error("No nodes matched the constraints specified.")
            process.exit(1);
        }
        else if (nodes.length < containers.length) {
            if (!overprovision) {
                console.error("Not enough nodes matched (", nodes.length,
                ") for the specified container array (", containers.length,
                ") and overprovision is not enabled.");
                process.exit(1);
            }
        }
        else if (nodes.length == containers.length) {
            // exact match then run them straight
            for (var i = containers.length - 1; i >= 0; i--) {
                containers[i].node = nodes[i];
            };
        }
        else {
            // too many nodes matched!
            console.error("Too many nodes matched (", nodes.length, ") for the specified container array (", containers.length, ").");
            process.exit(1);
        }
        // generate the docker commands
        for (var i = containers.length - 1; i >= 0; i--) {
            var container = containers[i];
            (function (container) {
                var cmdline = 'docker ';
                cmdline += process.argv.slice(2).join(' ').replace(argv.name, container.name);
                // run in child process
                var opts = {
                    env: {
                        'DOCKER_HOST': config.nodes[container.node].ip+':'+config.nodes[container.node].port
                    }
                };
                var child = child_process.exec(cmdline, opts, function (err, stdout, stderr) {
                    if (!err) {
                        // expect just container id
                        console.log(container.node, ":", stdout.trim());
                    } else {
                        // should show error
                        console.error(container.node, ":", stderr);
                    }
                });
            })(container);
        };
    })
    .command('start', 'Start one or more stopped containers')
    .command('stop', 'Stop one or more running containers')
    .command('kill', 'Kill one or more running containers')
    .command('rm', 'Remove one or more containers')
    .command('pull', 'Pull an image or a repository from a registry')
    .command('rmi', 'Remove one or more images')
    .command('ps', 'List containers')
    .demandCommand(1)
    .help('h')
    .alias('h', 'help')
    .argv
;